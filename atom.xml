<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Daniel Reuterwall]]></title>
  <link href="http://daniel.reuterwall.com/atom.xml" rel="self"/>
  <link href="http://daniel.reuterwall.com/"/>
  <updated>2013-04-13T14:07:08+02:00</updated>
  <id>http://daniel.reuterwall.com/</id>
  <author>
    <name><![CDATA[Daniel Reuterwall]]></name>
    <email><![CDATA[daniel@reuterwall.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Restrict Access]]></title>
    <link href="http://daniel.reuterwall.com/blog/2013/04/03/restrict-access/"/>
    <updated>2013-04-03T22:11:00+02:00</updated>
    <id>http://daniel.reuterwall.com/blog/2013/04/03/restrict-access</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>Last time we setup our staging environment and added a configuration property just to show how to work with different configuration between different environments. Today we&#8217;ll look at how to restrict access to our staging environment. We don&#8217;t want just anybody to be able to see our latest features before we release them.</p>

<p>The complete source code from this post is available in the <a href="https://github.com/danielreuterwall/play-basicauth">play-basicauth Github repository</a>.</p>

<p>For simplicity, we&#8217;ll implement basic auth for our application. Really, there&#8217;s no reason to take it further then that, basic auth will suit our needs just fine. It&#8217;s easy and pretty straight forward to implement and it doesn&#8217;t interfere with our application.</p>

<p>What we need is first of all a way to determine if the environment should have access restrictions, we just want it for staging and not production. Then we need to intercept each request and validate the authentication.</p>

<p>The way basic authentication works is that for all unauthorized requests, the server should respond with a <code>401 Not Authorized</code> HTTP response code and a <code>WWW-Authenticate</code> HTTP header. The contents of the header should be as follows:</p>

<pre><code>WWW-Authenticate: Basic realm="insert realm"
</code></pre>

<p>We&#8217;ll add some configuration properties to enable basic auth on staging and also to set the realm to be used. In <code>staging.conf</code>:</p>

<pre><code>basicAuth.enable=true
basicAuth.realm="Access is restricted, although any credentials will do."
</code></pre>

<p>The realm is supposed to be an opaque value identifying the restricted area of the server but we&#8217;ll give an informative message along with it. For this tutorial we&#8217;ll let any credentials pass but we&#8217;ll open up for real authentication logic for you to implement.</p>

<p>So, the configuration needs to be read and the requests needs to be intercepted. The place for this is <a href="http://www.playframework.com/documentation/2.1.0/JavaGlobal">Play&#8217;s Global object</a>. It&#8217;s a regular Java case that must be defined in the root package and extends <code>GlobalSettings</code>. Here we can intercept, among other things, application start-up as well as individual requests. Perfect for our needs.</p>

<p>When the application starts we&#8217;ll check the configuration to see if we should setup basic auth for this environment. In the global object we override the <code>onStart(Application)</code> method to do our initial check. From the app object we can get our configuration object and check our <code>basicAuth.enable</code> property.</p>

<pre><code>Configuration configuration = app.configuration();
basicAuth = configuration.getBoolean("basicAuth.enable");
</code></pre>

<p>Now if we find that we do need to setup basic auth we should intercept each request, validate the authentication and respond with the proper response code and header mentioned earlier if the user has not yet been authenticated. To keep our Global object as clean as possible we&#8217;ll move out the logic directly connected to basic auth to a separate class, <code>BasicAuth.java</code>. This class will be responsible for creating a proper response when authorization is needed and validating the credentials given by the user.</p>

<p>This leaves just a few lines of code to out global object and more specifically to the <code>onRequest(Request, Method)</code> method.</p>

<pre><code>public Action onRequest(Request request, Method actionMethod) {
    if(protectAll &amp;&amp; !basicauth.authenticate(request)) {
        return basicauth.getUnauthorizedAction();
    }

    return super.onRequest(request, actionMethod);
}
</code></pre>

<p>Our complete <code>Global.java</code> implementation now looks like this:</p>

<div><script src='https://gist.github.com/5347792.js'></script>
<noscript><pre><code></code></pre></noscript></div>


<p>We haven&#8217;t really touched on the <code>BasicAuth.java</code> yet but its responsibilities are authenticate the request and generate with a proper <code>Action</code> response object in case of an unauthorized request. As we can see in the code above it is created with an <code>Validator</code> allowing your own authentication logic. For this tutorial we&#8217;ll settle with the <code>AnythingGoesValidator</code> that will accept all client provided creadentials. Let&#8217;s have a closer look at how our <code>BasicAuth.java</code>.</p>

<div><script src='https://gist.github.com/5347952.js'></script>
<noscript><pre><code></code></pre></noscript></div>


<h2>Conclusion</h2>

<p>Although we could make this whole implementation a bit more elegant it will surely fulfill our needs. Without much effort the <code>Validator</code> could be changed to one that validates the credentials against some datastore records or really any other storage of choice.</p>

<p>The staging environment is now restricted from public access and we can finally start our real work and develop amazing features for our future clients.</p>

<p>I&#8217;ve found this setup useful and I hope you will to.
Best of luck, see you around!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up a Staging Environment]]></title>
    <link href="http://daniel.reuterwall.com/blog/2013/01/16/setting-up-a-staging-environment/"/>
    <updated>2013-01-16T21:40:00+01:00</updated>
    <id>http://daniel.reuterwall.com/blog/2013/01/16/setting-up-a-staging-environment</id>
    <content type="html"><![CDATA[<h2>Setup up staging</h2>

<p>Testing is an essential part of the development process. With Play, TDD and testing in general is made easy but that’s out of scope for this tutorial. What we’ll focus on here is to setup a staging environment for our project so we can test new features in a production like environment before we push them to production.</p>

<p>Working with <a href="http://devcenter.heroku.com/articles/multiple-environments">multiple environments on Heroku</a> is well documented in the Heroku Dev Center. Basically you just need to create a new Heroku app where you deploy your project. Some tweaks to handle different configuration is still needed though. By the end of this post you should have an understanding of basics and the necessary steps to do this.</p>

<p>We’ll start with creating our new app for the staging environment. Keeping things simple, we’ll just name it playtuts-staging.</p>

<pre><code>$ heroku apps:create playtuts-staging
</code></pre>

<p>Of course we need to be able to push our code to the newly created Heroku app so we’ll add a new git remote pointing to the git URL given to us from the previous output.</p>

<pre><code>$ git remote add staging git@heroku.com:playtuts-staging.git
</code></pre>

<p>One thing to address now is that the remote created in the previous post is named heroku. Your can check your existing remotes with the git remote command. This can of course be a bit confusing so let’s rename it to production instead.</p>

<pre><code>$ git remote rename heroku production
</code></pre>

<p>So now we’re ready to do our first push to the staging repository and deploy our application in the staging environment.</p>

<pre><code>$ git push staging master
</code></pre>

<p>After the deployment has completed we can open up our browser and check that everything worked as expected. The URL for the staging environment is <a href="http://playtuts-staging.herokuapp.com">http://playtuts-staging.herokuapp.com</a>.</p>

<p><img src="http://daniel.reuterwall.com/images/posts/staging-running.png" title="Playtuts project running in staging environment" ></p>

<p>The output looks just like the one from when we deployed our project last time in the environment from now on referred to as <em>production</em>.</p>

<h2>Different configuration</h2>

<p>Good progress so far. Now, we’ll have a look at how we can set different configuration for the two environments, staging and production. You’d want this for datastore connection properties et.c. To show how this could be done we’ll modify our welcome screen to print a configuration property identifying the current environment.</p>

<p>The default configuration for a Play application is defined in <code>conf/application.conf</code>. You can however add additional configuration files and use system properties to specify which one to be used. More on this can be found in the <a href="http://www.playframework.com/documentation/2.1.0/Configuration">configuration section in the Play documentation</a>.</p>

<p>For our project we’ll create two new configuration files, <code>production.conf</code> and <code>staging.conf</code>. Both will include the default configuration to keep just the environment specific properties managed outside the <code>application.conf</code>.</p>

<pre><code>include "application.conf"
environment.name="production"

include "application.conf"
environment.name="staging"
</code></pre>

<p>We’ll then need to add a environment variable for each Heroku app to make sure our Play application uses the correct configuration file. You can check the current environment variable using the Heroku CLI.</p>

<pre><code>$ heroku config --app playtuts
$ heroku config --app playtuts-staging
</code></pre>

<p>With the system property named <code>config.resource</code> we can specify an alternative configuration file. Being a Java application we simply need to add it to our <code>JAVA_OPTS</code>. Make sure you keep the existing values and not just overwrite the <code>JAVA_OPTS</code>.</p>

<pre><code>$ heroku config:add JAVA_OPTS="-Xmx384m -Xss512k -XX:+UseCompressedOops -Dconfig.resource=production.conf" --app playtuts
$ heroku config:add JAVA_OPTS="-Xmx384m -Xss512k -XX:+UseCompressedOops -Dconfig.resource=staging.conf" --app playtuts-staging
</code></pre>

<p>Finally we’ll modify the output on our welcome screen to include our newly added configuration property. To read the configuration we need to import the class <code>play.api.Play</code> which gives us access to bunch of global features among them the current application which in turn gives access to the configuration. We’ll remove the default Play welcome message and add our own.</p>

<div><script src='https://gist.github.com/5304619.js'></script>
<noscript><pre><code></code></pre></noscript></div>


<p>That’s it. Now we just need to push it out to our Heroku apps and be amazed over what we’ve accomplished. Of course we’ll do things in the right order. Check locally with play run, then the push to staging before we finally push to production but you already had that in mind right!?</p>

<h2>Conclusion</h2>

<p>We&#8217;ve seen how easy it is to setup additional environments when working with Heroku. The tricky part here was to enable separate configurations between the different environments but then again, it didn&#8217;t take that much effort to accomplish it.</p>

<p>Moving forward we&#8217;ll have a look at how to restrict access to the staging environment, stay tuned&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Play in the Cloud]]></title>
    <link href="http://daniel.reuterwall.com/blog/2013/01/08/play-in-the-cloud/"/>
    <updated>2013-01-08T21:26:00+01:00</updated>
    <id>http://daniel.reuterwall.com/blog/2013/01/08/play-in-the-cloud</id>
    <content type="html"><![CDATA[<h2>Create your Play project</h2>

<p>In this first part of Play with multiple environments on Heroku, we’ll start off simple and create a new Play project and deploy it to Heroku. The full process is even documented in <a href="http://www.playframework.com/documentation/2.1.0/ProductionHeroku">the official Play Framework documentation</a>.</p>

<p>If you haven’t started using Play, simply download it from the the their <a href="http://www.playframework.com/download">download section</a>. Extract it in a folder of choice and add the play executable to your <code>PATH</code>.</p>

<p>Initially, the most time consuming question is of course naming your project. We’ll name this project playtuts, in honor to <a href="http://envato.com">Envato</a> and their excellent Tuts+ network, make sure you check it out if you’re not already hooked.</p>

<pre><code>$ play new playtuts
</code></pre>

<p><img src="http://daniel.reuterwall.com/images/posts/create-playtuts.png" title="Creating the playtuts project" ></p>

<p>We chose to <em>Create a simple Java application</em> for the unfortunate reason that I’m not yet so familiar with Scala. It will however not affect this tutorial.</p>

<p>We should now have our project in a subfolder named playtuts so let’s fire it up to see that we managed to complete this first crucial step.</p>

<pre><code>$ cd playtuts
$ play run
</code></pre>

<p><img src="http://daniel.reuterwall.com/images/posts/local-running.png" title="Playtuts project running locally" ></p>

<p>Seeing this screen in our browser at <a href="http://localhost:9000">http://localhost:9000</a> tells us we’re on track. The page now shows the default Play welcome message.</p>

<p>After this great accomplishment we naturally want to see this running in the cloud so we can show our parents and get the flatter we so rightfully deserve.</p>

<h2>Deploy in Heroku</h2>

<p>The cloud platform we’ve chosen is <a href="http://www.heroku.com">Heroku</a>. For those unfortunate ones of you not familiar with Heroku, it’s a very flexible PAAS that is greatly documented and uses git for deployment. Checkout the <a href="https://devcenter.heroku.com/">Heroku DevCenter</a> and embrace the feeling that this is how it really should be done.</p>

<p>Further more, if you haven’t started using Heroku. Sign up for free and install the <a href="https://toolbelt.heroku.com/">Heroku Toolbelt</a>.</p>

<p>With the command line client in place we can now create an Heroku app for our project.</p>

<pre><code>$ heroku apps:create playtuts
</code></pre>

<p><img src="http://daniel.reuterwall.com/images/posts/create-heroku-app.png" title="Creating the Heroku app" ></p>

<p>What we get from this command is, as stated in the output, an Heroku app serving from <a href="http://playtuts.herokuapp.com">http://playtuts.herokuapp.com</a> and a remote git repository where we’ll deploy our project.</p>

<p>As all deployments are made through git we need to create our local git repository.</p>

<pre><code>$ git init
$ git add .
$ git commit -m "Initial commit"
</code></pre>

<p>Now we’re all set for our first cloud deployment. Add a git remote to the git repository given to us when we created our Heroku app and push the project code.</p>

<pre><code>$ git remote add heroku git@heroku.com:playtuts.git
$ git push heroku master
</code></pre>

<p><img src="http://daniel.reuterwall.com/images/posts/git-and-deploy.png" title="Setup Git repository and deploy to Heroku" ></p>

<p>Heroku will automatically detect that we deployed a Play application and start it accordingly. You’ll see the whole deployment process from the git push output. Once it’s ready you can again open up your browser and now hit <a href="http://playtuts.herokuapp.com">http://playtuts.herokuapp.com</a>.</p>

<p><img src="http://daniel.reuterwall.com/images/posts/heroku-running.png" title="Playtuts project running in the cloud" ></p>

<p>This super exciting screenshot shows that we successfully deployed our project to Heroku. The difference in appearance from our local site comes from the fact that the app now runs in production mode and the former welcome page is stripped.</p>

<h2>Conclusion</h2>

<p>This is what we&#8217;ve actually done.</p>

<pre><code>$ play new playtuts
$ heroku apps:create playtuts
$ git init
$ git add .
$ git commit -m "Initial commit"
$ git remote add heroku git@heroku.com:playtuts.git
$ git push heroku master
</code></pre>

<p>Through just these seven line we created our project and deployed in the cloud. That’s pretty amazing although in itself it doesn’t give us much. In the next post we’ll setup a staging environment for beta testing.</p>

<p>Stay tuned…</p>
]]></content>
  </entry>
  
</feed>
